#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'

SCHEMA_VERSION = 1

begin
  gem 'rAtom'
  require 'atom'
  require 'atom/pub'
rescue Gem::LoadError
  puts "This script requires the rAtom library."
  puts "Install using 'gem install rAtom'."
  exit(1)
end

begin
  gem 'sqlite3-ruby'
  require 'sqlite3'
rescue Gem::LoadError
  puts "This script requires the SQLite3/Ruby library."
  puts "Install using 'gem install sqlite3-ruby'"
  exit(1)
end

options = {}
opts = OptionParser.new do |opts|
  opts.banner = "Usage: import_item_cache --url=COLLECTOR_URL --db=DBFILE"
  opts.separator ""
  opts.separator "Specific options:"
  
  opts.on("-u", "--url=COLLECTOR_URL", :REQUIRED,
          "The URL of the collector from which items will be fetched.") do |url|
    options[:url] = url
  end
  
  opts.on("-d", "--db=DBFILE", :REQUIRED,
          "The SQLite3 database to load the items into.") do |db|
    options[:db] = db
  end
  
  opts.on("-s", "--since=DATE", "The date to load items from. (Default is forever)") do |since|
    options[:since] = Time.parse(since)
  end
  
  opts.separator ""
  opts.separator "Common options:"
  
  opts.on_tail("-h", "--help", "Show this message") do 
    puts opts
    exit
  end  
  
  opts.separator ""
end

opts.parse!

if options[:url].nil? || options[:db].nil?
  puts opts
  exit(1)
end

unless File.exists?(options[:db])
  puts "Database file #{options[:db]} does not exist. Trying to create it..."
  
  this_file = File.expand_path(__FILE__)
  schema_location = File.join(File.dirname(this_file), '../share/classifier/initial_schema.sql')
  if File.exists?(schema_location) 
    system("cat #{schema_location} | sqlite3 #{options[:db]}")
    puts "Database created!"
  else
    puts "Could not find the initial schema file at #{schema_location}."
    puts "You can try creating the database using 'classifier --db #{options[:db]} --create-db'"
    exit(1)
  end
end

db = SQLite3::Database.new(options[:db])
db_schema_version = db.get_first_value('PRAGMA user_version').to_i
if SCHEMA_VERSION != db_schema_version
  puts "Schema version (#{db_schema_version}) incompatible with script version (#{SCHEMA_VERSION})"
  exit(1)
end

atom_service = Atom::Pub::Service.load_service(URI.parse(options[:url]))
num_feeds = atom_service.workspaces.first.collections.size
puts "About to import #{num_feeds} feeds into #{options[:db]}."
puts "Will fetch items since #{options[:since]}" if options[:since]

db.transaction do
  atom_service.workspaces.first.collections.each_with_index do |collection, index|
    feed = collection.feed
    feed_id = URI.parse(feed.id).fragment
    puts "\timporting (#{index}/#{num_feeds}) #{feed.title}"
    db.execute('insert into feeds (id, title) values (?, ?);', feed_id, feed.title)
    
    feed.each_entry(:paginate => true, :since => options[:since]) do |entry|
      entry_id = URI.parse(entry.id).fragment
      author = entry.authors.empty? ? nil : entry.authors.first.name
      db.execute("insert into entries "+
                    "(id, full_id, title, author, alternate, self, " +
                    "content, updated, feed_id, created_at) VALUES "+
                    "(:id, :full_id, :title, :author, :alternate, :self, " +
                    ":content, julianday(:updated), :feed_id, julianday(:created_at));",
                  :id => entry_id,
                  :full_id => entry.id,
                  :title => entry.title,
                  :author => author,
                  :alternate => entry.alternate.to_s,
                  :self => entry.self.to_s,
                  :content => entry.content.to_s,
                  :updated => entry.updated.strftime('%Y-%m-%d %H:%M:%S'),
                  :feed_id => feed_id,
                  :created_at => Time.now.strftime('%Y-%m-%d %H:%M:%S'))
    end
  end
end